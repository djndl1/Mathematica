#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\begin_modules
algorithm2e
theorems-ams-bytype
theorems-ams-extended-bytype
eqs-within-sections
figs-within-sections
tabs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "tgtermes" "default"
\font_sans "tgheros" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Algorithms
\end_layout

\begin_layout Standard
There are many general classes of problems that arise in discrete mathematics.
\end_layout

\begin_layout Definition
An algorithm is a finite sequence of precise instructions for performing
 a computation or for solving a problem.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
\emph on
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
Finding the maximum Element in a Finite Sequence 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default

\begin_inset Formula $max\left(a_{1},a_{2},\dots,a_{n}\colon\text{integers}\right)$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $max\coloneqq a_{1}$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $i\coloneqq2$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
if 
\begin_inset Formula $max<a_{i}$
\end_inset

 then 
\begin_inset Formula $max\coloneqq a_{i}$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
return 
\begin_inset Formula $max$
\end_inset


\end_layout

\end_inset


\series default
\emph default

\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout LyX-Code
(defun max-integer-iterative (lst)
\end_layout

\begin_layout LyX-Code
  (let ((max (car lst)))
\end_layout

\begin_layout LyX-Code
    (dolist (num (cdr lst))
\end_layout

\begin_layout LyX-Code
      (if (< max num)
\end_layout

\begin_layout LyX-Code
          (setf max num)))
\end_layout

\begin_layout LyX-Code
    max))
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout LyX-Code
(defun max-integer-recursive (lst)   
\end_layout

\begin_layout LyX-Code
    (if (eql (length lst) 1)       
\end_layout

\begin_layout LyX-Code
        (car lst)       
\end_layout

\begin_layout LyX-Code
        (let ((max (car lst)) 
\end_layout

\begin_layout LyX-Code
            (max-cdr (max-integer-recursive (cdr lst))))          
\end_layout

\begin_layout LyX-Code
            (if (< max max-cdr)
\end_layout

\begin_layout LyX-Code
                max-cdr
\end_layout

\begin_layout LyX-Code
                max)))) 
\end_layout

\begin_layout Paragraph
There are several properties that algorithms generally share:
\end_layout

\begin_layout Description
Input An algorithm has input values from a specified set.
\end_layout

\begin_layout Description
Output From each set of input values an algorithm produces output values
 from a specified set.
 The output values are the solution to the problem.
\end_layout

\begin_layout Description
Definiteness The steps of an algorithm must be defined precisely.
\end_layout

\begin_layout Description
Correctness An algorithm should produce the correct output values for each
 set of input values.
\end_layout

\begin_layout Description
Finiteness An algorithm should produce the desired output after a finite
 number of steps for any input in the set.
\end_layout

\begin_layout Description
Effectiveness It must be possible to perform each step of an algorithm exactly
 and in a finite amount of time.
\end_layout

\begin_layout Description
Generality The procedure should be applicable for all problems of the desired
 form, not just for a particular set of input values.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Searching
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
The linear search algorithm/sequential search 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
\emph default

\begin_inset Formula $linear\,search\left(x\colon\text{integer},a_{1},a_{2},\dots,a_{n}\colon\text{ distinct integers}\right)$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $i\coloneqq1$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
while 
\begin_inset Formula $\left(i\leq n\text{ and }x\neq a_{i}\right)$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad i\coloneqq i+1$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
if 
\begin_inset Formula $i\leq n$
\end_inset

 then 
\begin_inset Formula $location\coloneqq i$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
else 
\begin_inset Formula $location\coloneqq0$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
return 
\begin_inset Formula $location$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
The Binary Search Algorithm 
\begin_inset Formula $\Theta\left(\log_{2}n\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
\emph default

\begin_inset Formula $binary\,search\left(x\colon\text{integer},a_{1},a_{2},\dots,a_{n}\colon\text{increasing integers}\right)$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $i\coloneqq1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $j\coloneqq n$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
while 
\begin_inset Formula $i<j$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad m\coloneqq\lfloor\left(i+j\right)/2\rfloor$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
if 
\begin_inset Formula $x>a_{m}$
\end_inset

 then 
\begin_inset Formula $i\coloneqq m+1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
else 
\begin_inset Formula $j\coloneqq m$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
if 
\begin_inset Formula $x=a_{i}$
\end_inset

 then 
\begin_inset Formula $location\coloneqq i$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
else 
\begin_inset Formula $location=0$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
return 
\begin_inset Formula $location$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sorting
\end_layout

\begin_layout Standard
Sorting is putting the elements into a list in which the elements are in
 increasing order.
 An amazingly large percentage of computing resources is devoted to sorting
 one thing or another.
 More than 
\begin_inset Formula $100$
\end_inset

 sorting algorithms have been devised.
\end_layout

\begin_layout Subsubsection
Bubble sort
\end_layout

\begin_layout Standard
The bubble sort is one of the simplest sorting algorithms, but not one of
 the most efficient.
 It puts a list into increasing order successively comparing adjacent elements,
 interchanging them if they are in the wrong order.
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
The bubble sort 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
\emph default

\begin_inset Formula $bubblesort\left(a_{1},\dots,a_{n}\colon\text{ real numbers with }n\geq2\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $i\coloneqq1$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
for 
\begin_inset Formula $j\coloneqq1$
\end_inset

 to 
\begin_inset Formula $n-i$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad$
\end_inset


\series bold
\emph on
if 
\begin_inset Formula $a_{j}>a_{j+1}$
\end_inset

 then 
\series default
interchange 
\begin_inset Formula $a_{j}$
\end_inset

 and 
\begin_inset Formula $a_{j+1}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
insertion sort
\end_layout

\begin_layout Standard
In general, in the 
\begin_inset Formula $j$
\end_inset

th step of the insertion sort, the 
\begin_inset Formula $j$
\end_inset

th element of the list is inserted into the correct position in the list
 of the previously sorted 
\begin_inset Formula $j-1$
\end_inset

 elements.
 To insert the 
\begin_inset Formula $j$
\end_inset

th element in the list, a linear search technique is used.
\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
The insertion sort 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default

\begin_inset Formula $insertion\,sort\left(a_{1},a_{2},\dots,a_{n}\colon\text{real numbers with }n\geq2\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $j\coloneqq2$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad i\coloneqq1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
while 
\begin_inset Formula $a_{j}>a_{i}$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad i\coloneqq i+1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\hspace*{1em}m\coloneqq a_{j}$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
for 
\begin_inset Formula $k\coloneqq0$
\end_inset

 to 
\begin_inset Formula $j-i-1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad a_{j-k}\coloneqq a_{j-k-1}$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad a_{i}\coloneqq m$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Greedy Algorithms
\end_layout

\begin_layout Definition
greedy algorithms
\end_layout

\begin_layout Definition
Algorithms that make what seems to be the 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

 choice at each step are called 
\emph on
greedy algorithms.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
Greedy Change-Making Algorithm
\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
\emph default

\begin_inset Formula $change\left(c_{1},c_{2},\dots,c_{r}\colon\text{values of denominations of coins where }\right)$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $c_{1}>c_{2}>\cdots>c_{r};n\colon\text{a positive integer}$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $i\coloneqq1$
\end_inset

 to 
\begin_inset Formula $r$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad d_{i}\coloneqq0$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
while 
\series default
\emph default

\begin_inset Formula $n\geq c_{i}$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad d_{i}\coloneqq d_{i}+1$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad n\coloneqq n-c_{i}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are sets of coins for which the greedy algorithm does not necessarily
 produce change using the fewest coins possible.
 For example, 
\begin_inset Formula $\left(25,10,1\right)$
\end_inset

 to change 
\begin_inset Formula $30$
\end_inset

.
\end_layout

\begin_layout Theorem
The greedy Change-Making algorithm produces change using the fewest coins
 possible.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
Greedy Algorithm for Scheduling Talks
\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
\emph default

\begin_inset Formula $(s_{1}\leq s_{2}\leq\cdots\leq s_{n}\colon\text{ start times of talks}$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad e_{1}\leq e_{2}\leq\cdots\leq e_{n}\colon\text{ ending times of talks})$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $S\coloneqq\emptyset$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $j\coloneqq1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad$
\end_inset


\series bold
\emph on
if 
\series default
talk 
\begin_inset Formula $j$
\end_inset

 is compatible with 
\begin_inset Formula $S$
\end_inset

 
\series bold
\emph default
then
\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad S\coloneqq S\cup\left\{ \text{talk }j\right\} $
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
return 
\series default
\emph default

\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Unsolvable Halting Problem
\end_layout

\begin_layout Standard
It asks whether there is a procedure that takes as input a computer program
 and input to the program and determines whether the program will eventually
 stop when run with this input.
\end_layout

\begin_layout Proof
Assume there is a solution 
\begin_inset Formula $H\left(P,I\right)$
\end_inset

 to the problem, which outputs 
\begin_inset Quotes eld
\end_inset

Loops forever
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

halts
\begin_inset Quotes erd
\end_inset

.
 Define another procedure 
\begin_inset Formula $K\left(P\right)$
\end_inset

 that outputs exactly the opposite to 
\begin_inset Formula $H\left(P,P\right)$
\end_inset

.
 
\begin_inset Formula $H\left(K,K\right)$
\end_inset

 yields a contradiction.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
The Growth of Functions
\end_layout

\begin_layout Standard
Big-O notation is used extensively to estimate the number of operations
 an algorithm uses as its input grows.
 With help of this notation, we can determine whether it is practical to
 use a particular algorithm to solve a problem as the size of the input
 increases.
\end_layout

\begin_layout Definition
Big-O notation
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 be functions from the set of integers or the set of real numbers to the
 set of real numbers.
 We say that 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g\left(x\right)\right)$
\end_inset

 if there are constants 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 s.t
\begin_inset Formula 
\[
\left|f\left(x\right)\right|\leq C\left|g\left(x\right)\right|
\]

\end_inset

whenever 
\begin_inset Formula $x>k$
\end_inset

.
 The constants 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 are called 
\emph on
witness 
\emph default
to the relationship 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g\left(x\right)\right)$
\end_inset

.
 We say that two funcitons 
\begin_inset Formula $f\left(x\right)$
\end_inset

 and 
\begin_inset Formula $g\left(x\right)$
\end_inset

 that satisfy both of these big-O relationships are of the 
\emph on
same order.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
A polynomial of degree 
\begin_inset Formula $n$
\end_inset

 or less is 
\begin_inset Formula $O\left(x^{n}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Formula $\log n!$
\end_inset

 is 
\begin_inset Formula $O\left(n\log n\right)$
\end_inset

, taking 
\begin_inset Formula $C=1$
\end_inset

 and 
\begin_inset Formula $k=1$
\end_inset

 as witnesses.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Formula $\log_{b}n$
\end_inset

 is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $1,\log n,n,n\log n,n^{2},2^{n},n!$
\end_inset


\end_layout

\begin_layout Standard
TODO: plot all the above functions.
\end_layout

\begin_layout Theorem
Suppose that 
\begin_inset Formula $f_{1}\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g_{1}\left(x\right)\right)$
\end_inset

 and that 
\begin_inset Formula $f_{2}\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g_{2}\left(x\right)\right)$
\end_inset

.
 Then 
\begin_inset Formula $\left(f_{1}+f_{2}\right)\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\max\left(\left|g_{1}\left(x\right)\right|,\left|g_{2}\left(x\right)\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
Suppose that 
\begin_inset Formula $f_{1}\left(x\right)$
\end_inset

 and 
\begin_inset Formula $f_{2}\left(x\right)$
\end_inset

 are both 
\begin_inset Formula $O\left(g\left(x\right)\right)$
\end_inset

.
 Then 
\begin_inset Formula $\left(f_{1}+f_{2}\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g\left(x\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
Suppose that 
\begin_inset Formula $f_{1}\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g_{1}\left(x\right)\right)$
\end_inset

 and 
\begin_inset Formula $f_{2}\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g_{2}\left(x\right)\right)$
\end_inset

.
 Then 
\begin_inset Formula $\left(f_{1}f_{2}\right)\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(\left(g_{1}g_{2}\right)\left(x\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Big-
\begin_inset Formula $\Omega$
\end_inset

 notation
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 be functions from the set of integers or the set of real numbers to the
 set of real numbers.
 We say that 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Omega\left(g\left(x\right)\right)$
\end_inset

 if there are positive constants 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula 
\[
\left|f\left(x\right)\right|\geq C\left|g\left(x\right)\right|
\]

\end_inset

whenever 
\begin_inset Formula $x>k$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Proposition
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Omega\left(g\left(x\right)\right)$
\end_inset

 iff 
\begin_inset Formula $g\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(f\left(x\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Often, it is important to know the order of growth of a function in terms
 of some relatively simple reference function.
 Knowing the order of growth requires that we have both an upper bound and
 a lower bound for the size of the function.
\end_layout

\begin_layout Definition
Big-Theta notation
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 be functions from the set of integers or the set of real numbers to the
 set of real numbers.
 We say that 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Theta\left(g\left(x\right)\right)$
\end_inset

 if 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $O\left(g\left(x\right)\right)$
\end_inset

 and 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Omega\left(g\left(x\right)\right)$
\end_inset

.
 When 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Theta\left(g\left(x\right)\right)$
\end_inset

 we say 
\begin_inset Formula $f$
\end_inset

 is 
\emph on
big-theta 
\emph default
of 
\begin_inset Formula $g\left(x\right)$
\end_inset

, that 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is of order 
\begin_inset Formula $g\left(x\right)$
\end_inset

 and that 
\begin_inset Formula $f\left(x\right)$
\end_inset

 and 
\begin_inset Formula $g\left(x\right)$
\end_inset

 are of 
\emph on
the same order.
\end_layout

\begin_layout Definition
\begin_inset Formula $f\left(x\right)$
\end_inset

 is 
\begin_inset Formula $\Theta\left(g\left(x\right)\right)$
\end_inset

 iff there are real numbers 
\begin_inset Formula $C_{1},C_{2}$
\end_inset

 and a positive real number 
\begin_inset Formula $k$
\end_inset

 s.t.
 
\begin_inset Formula 
\[
C_{1}\left|g\left(x\right)\right|\leq\left|f\left(x\right)\right|\leq C_{2}\left|g\left(x\right)\right|
\]

\end_inset

whenever 
\begin_inset Formula $x>k$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
Big-Theta is used to express both of lower-bound and upper-bound relationships.
 When big-Theta notation is used, the function 
\begin_inset Formula $g\left(x\right)$
\end_inset

 in 
\begin_inset Formula $\Theta\left(g\left(x\right)\right)$
\end_inset

 is a relatively simple reference function while 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is relatively complicated.
 Unfortunately, big-O notation is often used by careless writers and speakers
 as if it had the same meaning as bit-Theta notation.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $f\left(x\right)=a_{n}x^{n}+a_{n-1}x^{n-1}+\cdots+a_{1}x+a_{0}$
\end_inset

 where 
\begin_inset Formula $a_{n},a_{n-1},\dots,a_{0}$
\end_inset

 are real numbers with 
\begin_inset Formula $a_{n}\neq0$
\end_inset

.
 Then 
\begin_inset Formula $f\left(x\right)$
\end_inset

 is of order 
\begin_inset Formula $x^{n}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Complexity of Algorithms
\end_layout

\begin_layout Standard
An analysis of the time required to solve a problem of a particular size
 involves the 
\emph on
time complexity
\emph default
.
 An analysis of the computer memory required involves the 
\emph on
space complexity 
\emph default
of the algorithm.
 Considerations of the time and space complexity of an algorithm are essential
 when algorithms are implemented.
\end_layout

\begin_layout Subsection
Time complexity
\end_layout

\begin_layout Standard
The time complexity of an algorithm can be expressed in terms of the number
 of operations used by the algorithm when the input has a particular size.
\end_layout

\begin_layout Definition
worst-case complexity
\end_layout

\begin_layout Definition
the largest number of operations needed to solve the given problem using
 the algorithm on input of specified size.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
average-case analysis
\end_layout

\begin_layout Definition
The average number of operations used to solve the problem over all possible
 inputs of a given size.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Algorithm
Boolean product of Zero-One Matrices
\end_layout

\begin_layout Algorithm

\series bold
\emph on
procedure 
\series default
boolean product of Zero-One Matrices (
\emph default

\begin_inset Formula $A,B\colon\text{zero-one matrices}$
\end_inset


\emph on
)
\end_layout

\begin_layout Algorithm

\series bold
\emph on
for 
\begin_inset Formula $i\coloneqq1$
\end_inset

 to 
\begin_inset Formula $m$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\hspace*{1em}$
\end_inset


\series bold
\emph on
for 
\begin_inset Formula $j\coloneqq1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad c_{ij}=0$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad$
\end_inset


\series bold
\emph on
for 
\begin_inset Formula $q\coloneqq1$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset


\end_layout

\begin_layout Algorithm
\begin_inset Formula $\quad\quad\quad c_{ij}=c_{ij}\lor\left(a_{iq}\land b_{qj}\right)$
\end_inset


\end_layout

\begin_layout Algorithm

\series bold
\emph on
return 
\begin_inset Formula $C$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithmic Paradigms
\end_layout

\begin_layout Definition
algorithmic paradigm
\end_layout

\begin_layout Definition
a general approach based on a particular concept that can be used to construct
 algorithms for solving a variety of problems.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Brute-Force Algorithms
\end_layout

\begin_layout Standard
A problem is solved in the most straightforward manner based on the statement
 of the problem of the definitions of terms.
 Brute-force algorithms are designed to solve problems without regard to
 the computing resources required.
 In general, brute force algorithms are navie approaches for solving problems
 that do not take advantage of any special structure ofthe problem or clever
 ideas.
\end_layout

\begin_layout Example*
bubble, insertion and selection sorts;
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Complexity
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Complexity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Terminology
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(1\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constant
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logarithmic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(n\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linear
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(n\log n\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linearithmic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(n^{b}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Polynomial
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(b^{n}\right),b>1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exponential
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Theta\left(n!\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Factorial
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Definition
tractability
\end_layout

\begin_layout Definition
A problem that is solvable using an algorithm worst-case complexity is called
 
\emph on
tractable
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
A problem can be solved using an algorithm with polynomial worst-case time
 complexity is no guarantee that the problem can be solved in a reasonable
 amount of time for even relatively small input values.
 Many problems important in industry are thought be intractable but can
 be practically solved for essentially all sets of input that arise in daily
 life.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
P Versus NP
\end_layout

\begin_layout Standard
Many solvable problems are believed to have the property that no algorithm
 with polynomial worst-case time complexity solves them, but that a solution,
 if known, can be checked in polynomial time.
\end_layout

\begin_layout Definition
Class NP (nondeterministic polynomial), Class P
\end_layout

\begin_layout Definition
Problems for which a solution can be checked in polynomial time; tractable
 problems are said to belong to class P.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
NP-complete problems
\end_layout

\begin_layout Definition
If any of NP-complete problems can be solved by a polynomial worst-case
 time algorithm, then all problems in the class NP can be solved by polyniomial
 worst-case time algorithms.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
The P versus NP problem asks whther NP equals P.
 The P versus NP problem is one of the most famous unsolved problems in
 the mathematical sciences.
\end_layout

\begin_layout Section
Modeling Computation
\end_layout

\begin_layout Standard
There are three types of structures used in models of computation: grammars,
 finite-state machines, and Turing machines.
\end_layout

\begin_layout Subsection
Languages and Grammars
\end_layout

\begin_layout Standard
Grammars are used to generate the words of a language and to determine whether
 a word is in a language.
 Formal languages are generated by grammars, provide modes both for natural
 languages and for programming languages.
 Formal language is specified by a well-defined set of rules of syntax.
\end_layout

\begin_layout Subsubsection
Phrase-Structure Grammars
\end_layout

\begin_layout Definition
vocabulary, symbols, word, string
\end_layout

\begin_layout Definition
A 
\emph on
vocabulary 
\emph default
or 
\emph on
alphabet 
\emph default

\begin_inset Formula $V$
\end_inset

 is a finite, nonempty set of elements called 
\emph on
symbols
\emph default
.
\end_layout

\begin_layout Definition
A 
\emph on
word 
\emph default
or 
\emph on
sentence 
\emph default
over 
\begin_inset Formula $V$
\end_inset

 is a string of finite length of elements of 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Definition
The 
\emph on
empty string 
\emph default
or 
\emph on
null string
\emph default
 denoted by 
\begin_inset Formula $\lambda$
\end_inset

 is the string containing no symbols.
\end_layout

\begin_layout Definition
A 
\emph on
language 
\emph default
over 
\begin_inset Formula $V$
\end_inset

 is a subset of 
\begin_inset Formula $V^{*}$
\end_inset

, the set of all words over 
\begin_inset Formula $V$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
Another way to specify a langeuage is through the use of a grammar.
 A grammar provides a set of symbols of various types and a set of rules
 for producing words.
 Some of the elements of the vocabulary cannot be replaced by other symbols,
 and they are called 
\emph on
terminals, 
\emph default
otherwise 
\emph on
nonterminals
\emph default
.
 The elements of the vocabulary that we always begin with are called 
\emph on
start symbol, 
\emph default

\begin_inset Formula $S$
\end_inset

.
 The rules that specify when a string from 
\begin_inset Formula $V^{*}$
\end_inset

 can be replaced with another string are called the 
\emph on
productions
\emph default
 of the grammar.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
phrase-structure grammar
\end_layout

\begin_layout Definition
A phrase structure grammar 
\begin_inset Formula $G=\left(V,T,S,P\right)$
\end_inset

 consists of a vocabulary 
\begin_inset Formula $V$
\end_inset

, a subset 
\begin_inset Formula $T$
\end_inset

 of 
\begin_inset Formula $V$
\end_inset

 consisting of terminal symbols, a start symbol 
\begin_inset Formula $S$
\end_inset

 and a finite set of productions 
\begin_inset Formula $P$
\end_inset

.
 The set 
\begin_inset Formula $V-T$
\end_inset

 or 
\begin_inset Formula $N$
\end_inset

 are the set of 
\emph on
nonterminal symbols.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Example*
Let 
\begin_inset Formula $G=\left(V,T,S,P\right)$
\end_inset

, where 
\begin_inset Formula $V=\left\{ a,b,A,B,S\right\} $
\end_inset

, 
\begin_inset Formula $T=\left\{ a,b\right\} $
\end_inset

, 
\begin_inset Formula $P=\left\{ S\to ABa,A\to BB,B\to ab,AB\to b\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $G=\left(V,T,S,P\right)$
\end_inset

 be a phrase-structure grammar.
 Let 
\begin_inset Formula $w_{0}=lz_{0}r$
\end_inset

 and 
\begin_inset Formula $w_{1}=lz_{1}r$
\end_inset

 be strings over 
\begin_inset Formula $V$
\end_inset

.
 If 
\begin_inset Formula $z_{0}\to z_{1}$
\end_inset

 is a production of 
\begin_inset Formula $G$
\end_inset

, we say that 
\begin_inset Formula $w_{1}$
\end_inset

 is 
\emph on
directly derivable 
\emph default
from 
\begin_inset Formula $w_{0}$
\end_inset

 and we write 
\begin_inset Formula $w_{0}\Rightarrow w_{1}$
\end_inset

.
 If 
\begin_inset Formula $w_{0}\Rightarrow w_{1},w_{1}\Rightarrow w_{2},w_{2}\Rightarrow w_{3},\dots,w_{n-1}\Rightarrow w_{n}$
\end_inset

, then we say that 
\begin_inset Formula $w_{n}$
\end_inset

 is derivable from 
\begin_inset Formula $w_{0}$
\end_inset

 and denoted by 
\begin_inset Formula $w_{0}\overset{*}{\Rightarrow}w_{n}$
\end_inset

.
 The sequences of steps used to obtain 
\begin_inset Formula $w_{n}$
\end_inset

 from 
\begin_inset Formula $w_{0}$
\end_inset

 is called a 
\emph on
derivation.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $G=\left(V,T,S,P\right)$
\end_inset

 be a phrase-structure grammar.
 The 
\emph on
language generated by 
\begin_inset Formula $G$
\end_inset

 
\emph default
or the 
\emph on
language 
\emph default
of 
\begin_inset Formula $G$
\end_inset

, denoted by 
\begin_inset Formula $L\left(G\right)$
\end_inset

, is the set of all strings of terminals that are derivable from the starting
 statement 
\begin_inset Formula $S$
\end_inset

.
\begin_inset Formula 
\[
L\left(G\right)=\left\{ w\in T^{*}|S\overset{*}{\Rightarrow}w\right\} .
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Types of Phrase-Structure Grammars
\end_layout

\begin_layout Definition
type 0
\end_layout

\begin_layout Definition
Type 0 grammar has no restrictions on its productions.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
type 1
\end_layout

\begin_layout Definition
A type 1 grammar can have productions of the form 
\begin_inset Formula $w_{1}\to w_{2}$
\end_inset

, where 
\begin_inset Formula $w_{1}=lAr$
\end_inset

 and 
\begin_inset Formula $w_{2}=lwr$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 is a nonterminal symbol, 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 are strings of zero or more symbols, and 
\begin_inset Formula $w$
\end_inset

 is a nonempty string of symbols.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
Type 1 grammar generates 
\emph on
context-sensitive
\emph default
 languages because 
\begin_inset Formula $w_{1}$
\end_inset

 can be replaced by 
\begin_inset Formula $w_{2}$
\end_inset

 only when it is surrounded by the strings 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

.
 Context-senstive languages have the most complicated definition.
\end_layout

\begin_layout Definition
type 2
\end_layout

\begin_layout Definition
A type 2 grammar can have productions only of the form 
\begin_inset Formula $w_{1}\to w_{2}$
\end_inset

, where 
\begin_inset Formula $w_{1}$
\end_inset

 is a single nonterminal symbol.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
Type 2 gramamrs are called 
\emph on
context-free grammars because a nonterminal symbol can be replaced in a
 string whenever it occurs, no matter what else is in the string.
\end_layout

\begin_layout Definition
type 3, regular grammar
\end_layout

\begin_layout Definition
A type 3 grammar can have productions only of the form 
\begin_inset Formula $w_{1}\to w_{2}$
\end_inset


\end_layout

\begin_layout Definition
with 
\begin_inset Formula $w_{1}=A$
\end_inset

 and either 
\begin_inset Formula $w_{2}=aB$
\end_inset

 or 
\begin_inset Formula $w_{2}=a$
\end_inset

, where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 are nonterminal symbols and 
\begin_inset Formula $a$
\end_inset

 is a terminal symbol,
\end_layout

\begin_layout Definition
with 
\begin_inset Formula $w_{1}=S$
\end_inset

 and 
\begin_inset Formula $w_{2}=\lambda$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
noncontracting/monotonic production
\end_layout

\begin_layout Definition
A production of the form 
\begin_inset Formula $w_{1}\to w_{2}$
\end_inset

 is called noncontracting if the lenghth of 
\begin_inset Formula $w_{1}$
\end_inset

 is less than or equal to the length of 
\begin_inset Formula $w_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Remark*
Every production in a type 1 grammar, other than the production 
\begin_inset Formula $S\to\lambda$
\end_inset

 is noncontracting.
 The other way to define context-senstive grammars is by specifying that
 all productions are noncontracting.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Context-free and regular grammars play an importatnt role in programming
 languages.
 Context free grammars are used to define the syntax of almost all programming
 languages.
 Regular grammars are used to search text for certain patterns and in lexical
 analysis.
\end_layout

\end_body
\end_document
